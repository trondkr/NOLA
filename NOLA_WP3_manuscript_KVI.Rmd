
```{r settings, include=FALSE}
#rm(list = ls())
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(fig.retina = 1)

setwd("C:/NOLA-SIS_lokal/NOLA")

# libraries
library(ncdf4)
library(maps)
library(mapdata)
library(marmap)
library(ggmap)
library(tidyverse)
library(sp)
library(raster)
#library(captioner)
library(knitr)
library(grid)
library(gridExtra)
library(zoo)
library(flextable)
library(scales)
library(ggbreak)
library(aplot)
library(mgcv)

# Function to find first day of given month
firstDayMonth=function(x)
{           
  x=as.Date(as.character(x))
  day = format(x,format="%d")
  monthYr = format(x,format="%Y-%m")
  y = tapply(day,monthYr, min)
  first=as.Date(paste(row.names(y),y,sep="-"))
}

run_name_short <- c("Dissolved","Particulate")

colorcodes_areas <- c("#FF7F50","#8B8B00","#008B45", "#DA70D6","#56B4E9")


# Map basics
landcol<-"gray91"#"darkslategrey"
oceancol <-"white"
bat <- getNOAA.bathy(17.4, 19.25,69.25, 69.75, res = 0.1, keep = FALSE)
bat_xyz <- as.xyz(bat)

maparea <- ggplot() +
  geom_polygon(data = map_data("worldHires"), aes(x = long, y = lat, group = group), # Change to worldHires later
               colour = landcol, fill = landcol) +
  coord_cartesian(xlim = c(16.1, 21.8), ylim = c(69.2, 70.35) ) + 
  theme_void() +
  theme(panel.background=element_rect(fill = oceancol, colour = oceancol),
        panel.border = element_rect(colour = "black", fill=NA, linewidth = 0.5)) 

maparea_zoom <- ggplot() +
  geom_tile(data = bat_xyz, aes(x = V1, y = V2, fill = V3)) + 
  scale_fill_distiller(limits=c(-500,50), na.value = "white") + 
  geom_polygon(data = map_data("worldHires"), aes(x = long, y = lat, group = group), # Change to worldHires later
               colour = landcol, fill = landcol) +
  coord_cartesian(xlim = c(17.7, 19.2), ylim = c(69.28, 69.7) ) + 
  ylab("Latitude (°E)") + xlab("Longitude (°N)") +
  theme(legend.title = element_blank(),
    panel.background=element_rect(fill = oceancol, colour = oceancol),
    panel.grid.major=element_blank(),panel.grid.minor=element_blank(),
    panel.border = element_rect(colour = "black", fill=NA, size=0.5)) 

```


```{r read_opendrift_output, include=FALSE}
years <- c(2018,2020)
runs<-c("neutralParticles","sinkingParticles_-0.0003ms")

for(year in years){
  timespan<-paste0(year,"-1-1-1_to_",year,"-12-31-1")
  
for(i in 1:2){
  run_name <- paste0(runs[i],"_",timespan)
  resultfile <- paste0("../results/",run_name,".nc")
  DriftFile <- nc_open(resultfile, write=FALSE) #for nc
  #print(DriftFile)
  #id  <- ncvar_get(DriftFile, 'trajectory')  # Particle ID
  #Create vector of timesteps in days:
  timesteps  <- ncvar_get(DriftFile, 'time')  # seconds since 1970-01-01 00:00:00 
  dates <- as.Date(as.POSIXct(timesteps, origin="1970-01-01"))
  
  days_timestep<-diff(timesteps)[1]/(60*60*24) #days per timestep
  timesteps_days<-rep(NA,length(timesteps));timesteps_days[1]<-days_timestep 
  for (j in 2:length(timesteps_days)){timesteps_days[j]<-timesteps_days[j-1]+days_timestep}
  timesteps_days_rounded<-ceiling(timesteps_days)

  dates_days <- data.frame(day=timesteps_days_rounded,date=dates)
    assign(paste0("dates_days", year), dates_days)
  
  #Extract relevant variables
  status <- ncvar_get(DriftFile, 'status')    #0=active,<0=stranded/not yet released
  release_month <- ncvar_get(DriftFile, 'origin_marker');release_month[status<0]<-NA
  lon <- ncvar_get(DriftFile, 'lon');lon[status<0]<-NA
  lat <- ncvar_get(DriftFile, 'lat');lat[status<0]<-NA
  depth <- ncvar_get(DriftFile, 'z');depth[status<0]<-NA
  age_seconds <- ncvar_get(DriftFile, 'age_seconds');age_seconds[status<0]<-NA
  age_days <- floor(age_seconds/(60*60*24))
  bottom_depth <- ncvar_get(DriftFile, 'sea_floor_depth_below_sea_level');bottom_depth[status<0]<-NA
  
  nc_close(DriftFile)
  
  # Make dataframe of relevant variables
  dayvector <- rep(timesteps_days_rounded, each = dim(release_month)[2])
  datevector <- rep(dates, each = dim(release_month)[2])
  
  dat <- pivot_longer(as.data.frame(release_month), cols= 1:dim(release_month)[2], values_to = "release_month", names_to = "ID")  %>%
        mutate(day=dayvector)  %>%
        mutate(date=datevector)  %>%
        mutate(age=c(t(age_days)))  %>%
        mutate(lon=c(t(lon)))  %>%
        mutate(lat=c(t(lat)))  %>%
        mutate(depth=c(t(depth)))   %>%
        mutate(bottom_depth=c(t(bottom_depth)))   %>%
        filter(!is.na(release_month))
    
  # Remove particles after age 150 days drift / end of September - the sinking runs were terminated at day 274) 
  dat <- dat %>%
    filter(age<=93)

  assign(paste0(run_name,"_dat"), dat)
  rm(resultfile, DriftFile, timesteps, days_timestep, timesteps_days, timesteps_days_rounded, release_month, status, lon, lat, depth, age_seconds, age_days, datevector)
}

}


```

```{r read_river_file, include=FALSE}
RiverFile <- nc_open(paste0("../NorKyst_files/norfjords_160m_river.nc"), write=FALSE) #for nc
#print(RiverFile)
river_num <- ncvar_get(RiverFile, 'river')  # river number
timesteps_river <- ncvar_get(RiverFile, 'river_time')  # days since 1948-01-01 00:00:00 
dates_river <- as.Date(timesteps_river, origin="1948-01-01")

transport <- ncvar_get(RiverFile, 'river_transport') #river runoff vertically integrated mass transport, units: meter3 second-1 (day??)

timespan_min <- paste0(min(years), "-01-01")
timespan_max <- paste0(max(years), "-12-31-1")

dates_sel <- which(dates_river >= timespan_min & dates_river <= timespan_max)

river_sel <- 167 # Målselv

transport <- transport[river_sel, dates_sel]
#transport <- transport/1000 #(convert to m3^-1000)

transport <- data.frame(release_date=dates_river[dates_sel], transport=transport)
nc_close(RiverFile)

rm(river_num, timesteps_river, RiverFile, dates_sel, river_sel, dates_river)
```

```{r scale_by_river_volume, include=FALSE}

for(year in years){
  timespan<-paste0(year,"-1-1-1_to_",year,"-12-31-1")
                                
  for(x in 1:2){
  run_name <- paste0(runs[x],"_",timespan)
  
 # Full join doesn't work with dates  
  dat_releaseday <- get(paste0(run_name,"_dat")) %>%
    group_by(ID) %>% 
    slice(1)  %>% 
    mutate(release_date = as.character(date)) %>% 
    dplyr::select(c(ID,release_date))

  dat <- get(paste0(run_name,"_dat")) %>%
    mutate(date = as.character(date)) %>%
    left_join(dat_releaseday) %>%
    left_join(transport %>% mutate(release_date = as.character(release_date))) %>%
    mutate(vol_particle = transport/10) %>% # Scaled by 10 particles released per day
    mutate(date = as.Date(date))
  
  assign(paste0(run_name,"_dat"), dat)

  }
}

rm(dat_releaseday)
```

```{r define_boxes, include=FALSE}

local_box_lon = c(18.462861, 18.562647)
local_box_lat = c(69.304173, 69.357645)

adjacent_box_lon = c(18.5627, 19.05)
adjacent_box_lat = c(69.25, 69.357645)

inner_box_lon = c(18.349934, 18.718452)
inner_box_lat = c(69.357645, 69.438920)

outer_box_lon = c(17.823399, 18.718452)
outer_box_lat = c(69.438921, 69.571700)

# Outisde defines north and west of given latitudes (either) 
outside_lon = c(18.76,25)
outside_lat = c(69.571701, 70.1)


```

### USED FIGURES ###

```{r study_area}
#Plot distribution at release


txtsize <- 5

overview <- maparea +
  coord_cartesian(xlim = c(5, 29), ylim = c(59, 72))  +   
  geom_rect(linewidth=1, aes(xmin = 17.4, xmax = 19.25, ymin = 69.25, ymax= 69.7), fill=NA,color="black") +
  theme(axis.title.x=element_blank(),axis.title.y=element_blank(),
        axis.text.x=element_blank(),axis.text.y=element_blank(),
        axis.ticks.x=element_blank(),axis.ticks.y=element_blank())


zoomed <- maparea_zoom +
  coord_cartesian(xlim = c(17.4, 19.25), ylim = c(69.25, 69.7)) + 
  geom_rect(aes(xmin = min(local_box_lon), xmax = max(local_box_lon), ymin = min(local_box_lat), ymax = max(local_box_lat)),  color=colorcodes_areas[1], fill=NA, lwd=1.5) +
  geom_text(aes(x = min(local_box_lon)-0.1, y = mean(local_box_lat), label = "Local"),size = txtsize, vjust = 0, hjust = 0)+
  geom_rect(aes(xmin = min(adjacent_box_lon), xmax = max(adjacent_box_lon), ymin = min(adjacent_box_lat), ymax = max(adjacent_box_lat)),  color=colorcodes_areas[2], fill=NA, lwd=1.5) +
  geom_text(aes(x = mean(adjacent_box_lon)-0.1, y = mean(adjacent_box_lat), label = "Adjacent"),size = txtsize, vjust = 0, hjust = 0)+
  geom_rect(aes(xmin = min(inner_box_lon), xmax = max(inner_box_lon), ymin = min(inner_box_lat), ymax = max(inner_box_lat)),  color=colorcodes_areas[3], fill=NA, lwd=1.5) +
  geom_text(aes(x = min(inner_box_lon), y = max(inner_box_lat-0.04), label = "Inner"),size = txtsize, vjust = 0, hjust = 0) +
  geom_rect(aes(xmin = min(outer_box_lon), xmax = max(outer_box_lon), ymin = min(outer_box_lat), ymax = max(outer_box_lat)),  color=colorcodes_areas[4], fill=NA, lwd=1.5) +
  geom_text(aes(x = mean(outer_box_lon)-0.2, y = mean(outer_box_lat), label = "Outer"),size = txtsize, vjust = 0, hjust = 0) +
   geom_rect(aes(xmin = 10, xmax = min(outside_lon), ymin = min(outside_lat), ymax = max(outside_lat)), 
             colour="black", fill=NA, lwd=1.5, linetype="dashed") +
  geom_text(aes(x = min(outer_box_lon)-0.1, y = outside_lat+0.01, label = "Outside"),size = txtsize, vjust = 0, hjust = 0)+
  geom_point(data=dat  %>% filter(day==1),
             aes(x = lon, y = lat), size=0.1,color="black")  +
  geom_text(aes(x = max(local_box_lon), y = min(local_box_lat-0.06), label = "Release area"),size = 4, vjust = 0, hjust = 0) +
  geom_segment(aes(x = max(local_box_lon)+0.03, y = min(local_box_lat)-0.03, xend = mean(local_box_lon)+0.01, yend = min(local_box_lat)-0.002),
               arrow = arrow(length = unit(0.2, "cm")))

# study_area <- overview + annotation_custom(ggplotGrob(zoomed), xmin = 15, xmax = 31, 
#                        ymin = 58.5, ymax = 67)

study_area <- zoomed + annotation_custom(ggplotGrob(overview), xmin = 17.32, xmax = 18.1, 
                       ymin = 69.23, ymax = 69.41)

ggsave(study_area, file="../Figures/study_area.jpg", width = 180, height = 160, units = "mm", dpi = 300)

```


Total volume flux, vertical distribution of particles and percentage of particles within each area (weighted by volume flux).


```{r vol_and_dist}

txtsize <- 8
plotlist <- list() 
yupper <- c(90,82)

for(year in years){
  timespan<-paste0(year,"-1-1-1_to_",year,"-12-31-1")
  # Get dates for year:
  dat <- get(paste0(runs[1],"_",timespan,"_dat")) 
  
  transport_y <- transport  %>%
    filter(release_date >= min(dat$date) & release_date <=  max(dat$date)) %>%
    mutate(day = as.numeric(format(release_date, "%j")))  %>%
    mutate(month = as.numeric(format(release_date, "%m")))
  
# Total river volume
   plot_vol <- ggplot(data=transport_y, aes(x=day, y=transport)) +
     geom_bar(stat="identity", fill ="black", width = 0.5) +
     ylim(c(0,1220)) +
     scale_x_continuous(breaks = seq(15,360,by=30), labels = month.abb[seq(1,12)])  + 
     #scale_x_date(date_breaks = "months", labels = scales::label_date_short()) + 
     ylab("Total vol. flux (m3/d)") + xlab("Day") +
     theme_classic() + 
     theme(text=element_text(size=txtsize)) + xlab("") 
   
   # Add label
    if(year == years[1]){
      plot_vol <- plot_vol +
       ggtitle(paste0("A. ",year, " volume flux")) 
     } else {
      plot_vol <- plot_vol +
       ggtitle(paste0("B. ",year, " volume flux")) 
    } 
   
   plotlist <- append(plotlist, list(plot_vol)) 

   for(x in 1:2){
    dat <- get(paste0(runs[x],"_",timespan,"_dat")) %>%
        mutate(year = year(date), month = month(date), month_day = day(date))  %>% 
      # Fixing issue with some particles jumping to the surface/getting bottom depth 0 for silt particles
        mutate(bottom_depth = na_if(bottom_depth, 0)) %>%
        mutate(depth = ifelse(is.na(bottom_depth), NA, depth))
     
     # Plot % of particles present per box per month of simulation, scaled up by volume 
      
    # Sum up the volume of material per month (averaged over all days in the month)
    count_all <- dat %>% 
        group_by(month, month_day) %>% 
        summarise(tot_vol = sum(transport)) 

    for(i in c("local","adjacent","inner","outer")){
      lon_i <- get(paste0(i,"_box_lon"))
      lat_i <- get(paste0(i,"_box_lat"))
      
      count_i <- dat %>% 
        filter(lon>min(lon_i) & lon<max(lon_i)) %>% 
        filter(lat>min(lat_i) & lat<max(lat_i)) %>%
        group_by(month, month_day) %>% 
        summarise(vol_i = sum(transport)) %>% 
        rename(!!i:= vol_i)
      
      count_all <- count_all  %>%
        left_join(count_i)

      rm(count_i)
    }
      
    # For outside area: 
    count_outside <- dat %>% 
     # filter(lat>min(outside_lat) & lon<min(outside_lon) | lat>max(outside_lat) & lon<max(outside_lon)) %>% 
      filter(lat>min(outside_lat)) %>% 
        group_by(month, month_day) %>% 
        summarise(vol_i = sum(transport)) %>% 
        rename(outside = vol_i) 
    
    count_all <- count_all %>%
        left_join(count_outside) %>%
      mutate(across(c("local":"outside"),
           .fns = ~round(100*./tot_vol,2)))  %>%
      group_by(month) %>% 
      summarise(across(c("local":"outside"), ~ mean(.x, na.rm = TRUE)))
    
    rm(count_outside)
    
    plot_perc <-  count_all  %>%
      pivot_longer(cols = !month,
                      names_to = "Area",
                      values_to = "Fraction") %>%    
      mutate(Area = factor(Area, levels =c("local","adjacent","inner","outer","outside"))) %>%
      ggplot(aes(month, Fraction)) +   
      geom_bar(aes(fill = Area), position = "dodge", stat="identity") + 
      scale_fill_manual(values=colorcodes_areas) + 
      scale_x_continuous(breaks = seq(1,12), labels = month.abb[seq(1,12)])  + 
      ylim(c(0,yupper[x])) +
      xlab("Month") + ylab("Percentage in area") +
      ggtitle(run_name_short[x]) +
      theme_classic() + theme(text=element_text(size=txtsize), legend.position = "null")
      
    #Break y-axis
     if(x==2){
      plot_perc <- plot_perc +
      scale_y_break(c(16,60)) 
    } 
    
    # Add legend
    if(year == years[1] & x ==1){
      plot_perc <- plot_perc +
  theme(legend.position = c(.5, .9), legend.title = element_blank(), 
        legend.text = element_text(size = 6), legend.direction = "horizontal", legend.key.size = unit(0.4, 'cm'))
    }

    # Add label
    if(year == years[1] & x ==1){
      plot_perc <- plot_perc +
       ggtitle(paste0("C. ",year, " ",run_name_short[x])) 
      } else if (year == years[1] & x ==2) {
      plot_perc <- plot_perc +
       ggtitle(paste0("E. ",year, " ",run_name_short[x])) 
      } else if (year == years[2] & x ==1) {
        plot_perc <- plot_perc +
       ggtitle(paste0("D. ",year, " ",run_name_short[x])) 
     }  else {
      plot_perc <- plot_perc +
       ggtitle(paste0("F. ",year," ",run_name_short[x])) 
    } 
    
 plotlist <- append(plotlist, list(plot_perc)) 
} # Run
} # Year 
     

vol_and_dist <- plot_list(gglist=plotlist, ncol=2,byrow=FALSE)
ggsave(vol_and_dist, file="../Figures/vol_and_dist.jpg", width = 180, height = 180, units = "mm", dpi = 300)


# Create table
# all_perc <- bind_cols(bind_rows(perc_Dissolved_2018, perc_Dissolved_2019), 
#                       bind_rows(perc_Clay_2018[,-c(1:3)], perc_Clay_2019[,-c(1:3)]), 
#                       bind_rows(perc_Sand_2018[,-c(1:3)], perc_Sand_2019[,-c(1:3)]))
# 
# tab <- flextable(all_perc) %>% 
#   set_header_labels(values = c("Year","Month","N",rep(c("Local","Adjacent","Inner","inner","outer"),3)))  %>% 
#   add_header_row(values = c("", "Dissolved", "Clay", "Sand"),  colwidths = c(3, 5, 5, 5))  %>% 
#   colformat_num(j = 1,  big.mark = "") %>% 
#   vline(j = c(3,8,13))  %>% 
#   hline(i = 10) %>% 
#   rotate(j=1,rotation="btlr") %>% 
#   merge_v(j = 1)   %>% 
#   align(align = "center", part = "header")
# 
# tab

```

Spatial distribution of material at selected time points

```{r num_particles_day, eval=FALSE}

ext <- c(16.5, 22.8, 69.3, 70.1)

reso <- c(0.01,0.005)
fullRaster <- raster(resolution = reso, xmn=ext[1], xmx=ext[2], ymn=ext[3], ymx=ext[4])

zlims <- c(0,9.7)
plotlist <- list()

for(year in years){
  for(x in 1:2){
  timespan<-paste0(year,"-1-1-1_to_",year,"-12-31-1")
  dat <- get(paste0(runs[x],"_",timespan,"_dat")) 
  dat_sp <- SpatialPointsDataFrame(cbind(dat$lon,dat$lat), data=dat)
  days <- firstDayMonth(unique(dat_sp$date))[c(6,9)]

  for(i in 1:length(days)){
    dat_i <- dat_sp[dat_sp$date==days[i],]
    # Counting the number of particles:
    # rasterNumParts <- rasterize(x=dat_i[,"ID"], y=fullRaster, fun="count")
    # rasterNumParts <- as.data.frame(rasterNumParts , xy=T, na.rm=T)
    # maxval <- max(rasterNumParts$ID)
    
    # Summing the volume of particles:
    rasterNumParts <- rasterize(x=dat_i[,"vol_particle"], y=fullRaster, fun="sum")
    rasterNumParts <- as.data.frame(rasterNumParts , xy=T, na.rm=T)
    rasterNumParts$Number <- log(rasterNumParts$vol_particle+1)
    print(range(rasterNumParts$Number ))
    #maxval <- max(rasterNumParts$Number)

    plot_x <- maparea +
  coord_cartesian(xlim = ext[c(1,2)], ylim = ext[c(3,4)]) + 
  geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=Number), interpolate = TRUE) +
  scale_fill_gradientn(limits = zlims,
                       na.value = "grey", #na.value color same as color for max value
                       colours = c("purple","blue", "green","yellow","orange","red"),
                       name="Number") +
  #ggtitle(paste0(days[i], "\nMax: ", round(maxval))) +
  theme(axis.text.x=element_blank(),axis.ticks.x=element_blank(),
        axis.title.x=element_blank(),axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),axis.title.y=element_blank(),
        legend.position="none",
        plot.margin = unit(c(-2,0,-0.5,0), "lines"),
        plot.title=element_text(vjust = -14, hjust = 0.01),
        plot.subtitle = element_text(vjust= -14, hjust = 0.01),
        panel.border = element_rect(colour = "black", fill=NA, size=1))

# Add label
if(year == years[1] & x ==1 & i==1){
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("A. ", days[i]),
         subtitle = run_name_short[x])}
    else if (year == years[2] & x ==1 & i==1) {
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("B. ", days[i]),
         subtitle = run_name_short[x])} 
    else if (year == years[1] & x ==1 & i==2) {
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("C. ", days[i]),
         subtitle = run_name_short[x]) } 
    else if (year == years[2] & x ==1 & i==2) {
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("D. ", days[i]),
         subtitle = run_name_short[x]) 
} else if (year == years[1] & x ==2 & i==1) {
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("E. ", days[i]),
         subtitle = run_name_short[x])
} else if (year == years[2] & x ==2 & i==1) {
  plot_x <- plot_x +
  labs(x=NULL,y=NULL,
       title = paste0("F. ",days[i]),
       subtitle = run_name_short[x])
  } else if (year == years[1] & x ==2 & i==2) {
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("G. ", days[i]),
         subtitle = run_name_short[x])
}  else {
  plot_x <- plot_x +
    labs(x=NULL,y=NULL,
         title = paste0("H. ", days[i]),
         subtitle = run_name_short[x]) 
} 
    

    plotlist <- append(plotlist, list(plot_x)) 
  } # Days
  } # run
} # year

# Get legend
 lastplot <- maparea  +
    geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=Number), interpolate = TRUE) +
    scale_fill_gradientn(limits = zlims,
                         na.value = "grey", #na.value color same as color for max value
                         colours = c("purple","blue", "green","yellow","orange","red"), name="log(Volume)") +
    theme(legend.direction = "horizontal", legend.key.height = unit(0.2, 'cm')) 

  legend <- cowplot::get_legend(lastplot)
  plotlist <- append(plotlist, list(legend))
 

daily_dist <- grid.arrange(grobs=plotlist, layout_matrix = matrix(c(1:4,NA,5:9),ncol=2,byrow=FALSE), heights = c(rep(1,4),0.3))
ggsave(daily_dist, file="../Figures/daily_dist.jpg", width = 180, height = 200, units = "mm", dpi = 300)

```


Residence time per box (Difference between first and last time within box) and time to reach area, plotted per release month and run.

```{r residence_and_time_to_reach_box}

ylims <- c(0,95)
txtsize <- 8

plotlist <- list()

for(year in years){
  timespan<-paste0(year,"-1-1-1_to_",year,"-12-31-1")
  for(x in 1:2){
    dat <- get(paste0(runs[x],"_",timespan,"_dat"))

    # Plot time to reach box
    for(i in c("adjacent","inner","outer")){
      lon_i <- get(paste0(i,"_box_lon"))
      lat_i <- get(paste0(i,"_box_lat"))
      
      firstday_i <- dat %>% 
        filter(lon>min(lon_i) & lon<max(lon_i)) %>% 
        filter(lat>min(lat_i) & lat<max(lat_i)) %>%
        group_by(ID, release_month) %>% 
        summarise(firstday = min(age)) %>%
        mutate(region = i)
      
      assign(paste0("firstday_", i), firstday_i)
      rm(firstday_i)
    }
      
    # For outside area: 
    firstday_outside <- dat %>% 
      filter(lat>min(outside_lat)) %>% 
      group_by(ID, release_month) %>% 
      summarise(firstday = min(age)) %>%
      mutate(region = "outside")
    
    firstday_all <- rbind(firstday_adjacent, firstday_inner,
                           firstday_outer, firstday_outside)  %>%
      mutate(release_month = factor(release_month, levels=c(1:9)),
             region = factor(region, levels =c("adjacent","inner","outer","outside")))
    
    # print(firstday_all %>% 
    #   group_by(region, release_month) %>% 
    #   summarise(med_day = median(firstday), max_day = max(firstday)), n=50)
    
    plot_x <- 
      ggplot(data=firstday_all, aes(x=release_month, y=firstday, fill=region)) +
      geom_boxplot(size=0.1, outlier.size=0.1) +
      scale_fill_manual(values=colorcodes_areas[-1]) + 
      scale_x_discrete(breaks = seq(1,9), labels = month.abb[seq(1,9)])  + 
      ylim(ylims) + 
      xlab("") + ylab("") +
      theme_classic() + theme(legend.position = "null",  text=element_text(size=txtsize))
      
    # Ylab first year
    if(year == years[1]){
      plot_x <- plot_x +
        ylab("Time to reach")
    }
   
     # Add label
    if(year == years[1] & x ==1){
       plot_x <- plot_x +
           ggtitle(label=paste0("A. ",year), subtitle = run_name_short[x])
             } else if (year == years[2] & x ==1) {
        plot_x <- plot_x +
           ggtitle(label=paste0("B. ",year), subtitle = run_name_short[x])
        } else if (year == years[1] & x ==2) {
        plot_x <- plot_x +
       ggtitle(paste0("E. ",year), subtitle = run_name_short[x])
     }  else {
      plot_x <- plot_x +
       ggtitle(paste0("F. ",year), subtitle = run_name_short[x])
     } 
    
    plotlist <- append(plotlist, list(plot_x))

     rm(list=ls(pattern="firstday"))
      
    # Plot residence time
    for(i in c("local","adjacent","inner","outer")){
      lon_i <- get(paste0(i,"_box_lon"))
      lat_i <- get(paste0(i,"_box_lat"))
      
      residence_i <- dat %>% 
        filter(lon>min(lon_i) & lon<max(lon_i)) %>% 
        filter(lat>min(lat_i) & lat<max(lat_i)) %>%
        group_by(ID, release_month) %>% 
        summarise(residence = max(age+1)-min(age)) %>%
        mutate(region = i)
      
      assign(paste0("residence_", i), residence_i)
      rm(residence_i)
    }
      
    # For outside area: 
    residence_outside <- dat %>% 
      filter(lat>min(outside_lat)) %>% 
      group_by(ID, release_month) %>% 
      summarise(residence = max(age+1)-min(age)) %>%
      mutate(region = "outside")
    
    residence_all <- rbind(residence_local, residence_adjacent, residence_inner, residence_outer, residence_outside)  %>%
      mutate(release_month = factor(release_month, levels=c(1:9)),
             region = factor(region, levels =c("local","adjacent","inner","outer","outside")))
    
    plot_x <- 
      ggplot(data=residence_all, aes(x=release_month, y=residence, fill=region)) +
      geom_boxplot(size=0.1, outlier.size=0.1) +
      scale_fill_manual(values=colorcodes_areas) + 
     scale_x_discrete(breaks = seq(1,9), labels = month.abb[seq(1,9)])  + 
      ylim(ylims) + 
      xlab("") + ylab("") +
      theme_classic() + theme(legend.position = "null", text=element_text(size=txtsize))
   
    # Ylab to first year  
    if(year == years[1]){
      plot_x <- plot_x +
        ylab("Residence time")
    }
    
         # Add label
    if(year == years[1] & x ==1){
       plot_x <- plot_x +
           ggtitle(label=paste0("C. ",year), subtitle = run_name_short[x])
             } else if (year == years[2] & x ==1) {
        plot_x <- plot_x +
           ggtitle(label=paste0("D. ",year), subtitle = run_name_short[x])
        } else if (year == years[1] & x ==2) {
        plot_x <- plot_x +
       ggtitle(paste0("G. ",year), subtitle = run_name_short[x])
     }  else {
      plot_x <- plot_x +
       ggtitle(paste0("H. ",year), subtitle = run_name_short[x])
     } 

    # Legend to last plot
    if(year == years[2] & x == 2){
      plot_x <- plot_x +
        theme(legend.position = c(.45, -0.22), legend.title = element_blank(), 
              legend.text = element_text(size = txtsize), legend.direction = "horizontal", legend.key.size = unit(0.6, 'cm')) }
    
  
     plotlist <- append(plotlist, list(plot_x))
      rm(list=ls(pattern="residence_"))
  } # Run
} # Year

time_and_residence <- grid.arrange(grobs=plotlist, layout_matrix = matrix(c(1:8),ncol=2,byrow=FALSE), bottom=textGrob("Release month"))

ggsave(time_and_residence, file="../Figures/time_and_residence.jpg", width = 180, height = 200, units = "mm", dpi = 300)

```

Statistical tests, effect of volume at time to reach/residence time?
```{r stats_residence_and_time_to_reach_box}

# Calculate moving window of water volume transport (from release day and 4 following days)
# Log-transform to reduce influence of outliers?

transport <- transport %>% 
       mutate(transport_movavg = rollapply(transport, width = 5, FUN= mean, align = 'left', fill = NA)) %>%
 mutate(transport_movavg = log(transport_movavg))

newdat_firstday <- data.frame(transport_movavg=seq(min(transport$transport_movavg, na.rm=T),max(transport$transport_movavg, na.rm=T),length.out=100), region=rep(c("adjacent","inner","outer","outside"),each=100)) %>%
  mutate(region = factor(region, levels =c("adjacent","inner","outer","outside")))
  
newdat_residence <- data.frame(transport_movavg=seq(min(transport$transport_movavg, na.rm=T),max(transport$transport_movavg, na.rm=T),length.out=100), region=rep(c("local","adjacent","inner","outer","outside"),each=100)) %>%
  mutate(region = factor(region, levels =c("local","adjacent","inner","outer","outside")))

txtsize <- 8

plotlist <- list()

for(x in 1:2){
    print(x)
  # Combine data for the two years)
  df_list <- mget(ls(pattern = runs[x]))
  dat <- bind_rows(df_list) %>% 
    mutate(release_date = as.Date(release_date))

# Find time to reach box
  for(i in c("adjacent","inner","outer")){
      lon_i <- get(paste0(i,"_box_lon"))
      lat_i <- get(paste0(i,"_box_lat"))
      
      firstday_i <- dat %>% 
        filter(lon>min(lon_i) & lon<max(lon_i)) %>% 
        filter(lat>min(lat_i) & lat<max(lat_i)) %>%
        group_by(ID, release_date) %>% 
        summarise(firstday = min(age)) %>%
        mutate(region = i)  %>%
        left_join(transport)
      
      assign(paste0("firstday_", i), firstday_i)
      rm(firstday_i)
    }
      
    # For outside area: 
    firstday_outside <- dat %>% 
      filter(lat>min(outside_lat)) %>% 
      group_by(ID, release_date) %>% 
      summarise(firstday = min(age)) %>%
      mutate(region = "outside")  %>%
        left_join(transport)
    
    firstday_all <- rbind(firstday_adjacent, firstday_inner,
                           firstday_outer, firstday_outside)  %>%
      mutate(region = factor(region, levels =c("adjacent","inner","outer","outside")))
    
    
    
    mod_firstday <- gam(firstday ~ s(transport_movavg, by=region, k = 4) + region, data = firstday_all)
    
    print(summary(mod_firstday))
    predictions <- predict.gam(mod_firstday, newdata = newdat_firstday, se.fit = TRUE) 
    
    newdat_firstday <- newdat_firstday  %>%
        mutate(firstday = predictions$fit, 
               se = predictions$se.fit,
               lower = firstday - 1.96 * se,
               upper = firstday + 1.96 * se)
    
    plot_x <- ggplot(data = newdat_firstday, aes(x=transport_movavg, y = firstday, color=region)) +
      geom_line() +
      scale_color_manual(values=colorcodes_areas[-1]) + 
      geom_ribbon(data = newdat_firstday, aes(ymin = lower, ymax = upper, fill=region), colour = NA, alpha = 0.2) +
      scale_fill_manual(values=colorcodes_areas[-1]) + 
      ylim(c(0,60)) + 
      ylab("") +
      theme_classic() + theme(legend.position = "null",
                          axis.title.x=element_blank()) +
      geom_vline(xintercept = max(firstday_all$transport_movavg[firstday_all$release_date>"2018-12-31"])) +
      geom_vline(xintercept = max(firstday_all$transport_movavg[firstday_all$release_date<"2018-12-31"]), linetype=2) 

    # Ylab first plot
    if(x ==1){
      plot_x <- plot_x +
        ylab("Time to reach")}
   
     # Add label
    if(x ==1){
       plot_x <- plot_x +
           ggtitle(label="A.", subtitle = run_name_short[x])
             } else {
        plot_x <- plot_x +
           ggtitle(label="B.", subtitle = run_name_short[x])
        } 
    
    plotlist <- append(plotlist, list(plot_x))

    rm(list=ls(pattern="firstday_"))
      
    # Find residence time
    for(i in c("local","adjacent","inner","outer")){
      lon_i <- get(paste0(i,"_box_lon"))
      lat_i <- get(paste0(i,"_box_lat"))
      
      residence_i <- dat %>% 
        filter(lon>min(lon_i) & lon<max(lon_i)) %>% 
        filter(lat>min(lat_i) & lat<max(lat_i)) %>%
        group_by(ID, release_date) %>% 
        summarise(residence = max(age+1)-min(age)) %>%
        mutate(region = i) %>%
        left_join(transport)
      
      assign(paste0("residence_", i), residence_i)
      rm(residence_i)
    }
      
    # For outside area: 
    residence_outside <- dat %>% 
      filter(lat>min(outside_lat)) %>% 
        group_by(ID, release_date) %>% 
      summarise(residence = max(age+1)-min(age)) %>%
      mutate(region = "outside") %>%
        left_join(transport)
    
    residence_all <- rbind(residence_local, residence_adjacent, residence_inner, residence_outer, residence_outside)  %>%
      mutate(region = factor(region, levels =c("local","adjacent","inner","outer","outside")))
    
    mod_residence <- gam(residence ~ s(transport_movavg, by=region, k = 4) + region, data = residence_all)
    print(summary(mod_residence))

    predictions <- predict.gam(mod_residence, newdata = newdat_residence, se.fit = TRUE) 

    newdat_residence <- newdat_residence  %>%
        mutate(residence= predictions$fit, 
               se = predictions$se.fit,
               lower = residence - 1.96 * se,
               upper = residence + 1.96 * se)    
    
    
    plot_x <- ggplot(data = newdat_residence, aes(x=transport_movavg, y = residence, color=region)) +
      geom_line() +
      scale_color_manual(values=colorcodes_areas) + 
      ylim(0,90) + 
      ylab("") +
      geom_ribbon(data = newdat_residence, aes(ymin = lower, ymax = upper, fill=region), colour = NA, alpha = 0.2) +
      scale_fill_manual(values=colorcodes_areas) + 
      ylab("") +
      theme_classic() + theme(legend.position = "null",
                          axis.title.x=element_blank()) +
      geom_vline(xintercept = max(residence_all$transport_movavg[residence_all$release_date>"2018-12-31"])) +
      geom_vline(xintercept = max(residence_all$transport_movavg[residence_all$release_date<"2018-12-31"]), linetype=2) 
    
    # Ylab to first run  
    if(x == 1){
      plot_x <- plot_x +
        ylab("Residence time")
    }
    
      # Add label / legend
   if(x ==1){
       plot_x <- plot_x +
           ggtitle(label="C.", subtitle = run_name_short[x])
             } else {
        plot_x <- plot_x +
           ggtitle(label="D.", subtitle = run_name_short[x]) +
             theme(legend.position = c(.45, 0.95), legend.title = element_blank(), 
              legend.text = element_text(size = txtsize), legend.direction = "horizontal", legend.key.size = unit(0.6, 'cm')) 

        }
    
     plotlist <- append(plotlist, list(plot_x))
      rm(list=ls(pattern="residence_"))
  } # Run

time_and_residence_mods <- grid.arrange(grobs=plotlist, layout_matrix = matrix(c(1:4),ncol=2,byrow=FALSE), bottom=textGrob("Volume flux (log(m3/day))"))

ggsave(time_and_residence_mods, file="../Figures/time_and_residence_mods.jpg", width = 220, height = 160, units = "mm", dpi = 300)

```

Show example of particle remaining in adjacent area 
```{r single_particle_adjacent_area}
year<-2018
x<-1
timespan<-paste0(year,"-2-1-1_to_",year,"-12-31-1")
dat <- get(paste0(runs[x],"_",timespan,"_dat"))
i<-"inner"
lon_i <- get(paste0(i,"_box_lon"))
lat_i <- get(paste0(i,"_box_lat"))
firstday_i <- dat %>% 
         filter(lon>min(lon_i) & lon<max(lon_i)) %>% 
         filter(lat>min(lat_i) & lat<max(lat_i)) %>%
         group_by(ID, release_month) %>% 
         summarise(firstday = min(age)) %>%
         mutate(region = i)
view(firstday_i)


id_x <-  "V10543"
test <- dat  %>%
  filter(ID== id_x) 

anim <- ggplot(data=test,aes(x = lon, y = lat), size=0.1) +
  geom_point() +
  labs(title = 'Time (days): {frame_time}') +
  transition_time(age) 

# anim <- maparea_all +
#   coord_cartesian(xlim = c(17.4, 19.25), ylim = c(69.25, 69.7)) + 
#   geom_point(data=test,
#              aes(x = lon, y = lat), size=0.1)  +
#   labs(title = 'Time (days): {frame_time}') +
#   transition_time(age) 

animate(anim, duration = 20, width = 600, height = 600, renderer = gifski_renderer(loop=FALSE))
anim_save(file=paste0("../Figures/",id_x,".gif"))

```


For the upper area. Removed outer area


Time to reach box: First day within box, plotted per release month and particle type




## OLD STUFF ##
```{r particle_depth, eval=FALSE}

# Plot absolute depth and bottom depth:
  # dep_day <- dat %>% 
  #   filter(!is.na(depth)) %>% 
  #   group_by(month,day) %>%  
  #   summarise(lower_dep = quantile(depth, c(0.25)),
  #             med_dep = quantile(depth, c(0.5)),
  #             upper_dep = quantile(depth, c(0.75)))
  # 
  # bottom_day <- dat %>% 
  #   group_by(day) %>%  
  #   filter(!is.na(bottom_depth)) %>% 
  #   summarise(lower_dep = quantile(-bottom_depth, c(0.25)),
  #             med_dep = quantile(-bottom_depth, c(0.5)),
  #             upper_dep = quantile(-bottom_depth, c(0.75)))  %>% 
  #   filter(day != 1)
  # 
  #  plot_dep <- ggplot()  + 
  #     geom_ribbon(dat=dep_day, aes(x=day, ymin=lower_dep, ymax=upper_dep) ,alpha = 0.2) +
  #     geom_line(dat=dep_day, aes(x=day, y=med_dep)) + 
  #     coord_cartesian(ylim = c(-130, 0)) +
  #     # Add bottom depth
  #     geom_line(dat = bottom_day, aes(x=day, y= med_dep), col = "red") + 
  #     ggtitle(run_name_short[x]) +
  #     theme_minimal() +
  #     theme(text=element_text(size=txtsize), axis.text.x=element_text(angle=90,hjust=1,vjust=0.5),
  #               axis.title.y.right = element_text(color = "red")) +
  #    xlab("Day of simulation") + ylab("Particle depth / bottom depth") 
  

plotlist <- list()

for(x in 1:3){
    for(year in years){
      # Combine data from 2018 and 2019
      run_name <- paste0(runs[x],"_","2018-2-1-1_to_2018-12-31-1")
      dat_2018 <- get(paste0(run_name,"_dat")) 
      
      run_name <- paste0(runs[x],"_","2019-2-1-1_to_2019-12-31-1")
      dat_2019 <- get(paste0(run_name,"_dat")) 
    
      # Fixing issue with some particles jumping to the surface/getting bottom depth 0 for silt particles
      dat_comb <- rbind(dat_2018, dat_2019) %>% 
        filter(age != 0) %>%
        mutate(bottom_depth = na_if(bottom_depth, 0)) %>%
        mutate(depth = ifelse(is.na(bottom_depth), NA, depth))
      
    }
      # Plot absolute depth:
      plot_dep <- dat_comb  %>% 
        ggplot(aes(x=day, y=depth))+ 
    # Plot mean + confidence interval:
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, fill="grey")+
    # stat_summary(geom="line", fun=mean)+
   # Plot median + upper/lower quantiles:
        stat_summary(geom="ribbon", fun.min = function(x) quantile(x, 0.25), fun.max = function(x) quantile(x, 0.75), fill = "light grey") + ylab("") +
    stat_summary(geom="line", fun=median)+
    coord_cartesian(ylim = c(-130, 0)) +
    theme_minimal() +
    theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) +
    ggtitle(run_name_short[x])

    if(x == 1){
    plot_dep <- plot_dep + ylab("Median depth distribution") 
    }

    # Plot relative depth:
      plot_relative_dep <- dat_comb  %>% 
      mutate(relative_depth = round(100*(abs(depth)/bottom_depth)))  %>%
      mutate(relative_depth=replace(relative_depth, relative_depth > 100,100))  %>%
    ggplot(aes(x=day, y=relative_depth))+ 
   # Plot mean + confidence interval:
    # stat_summary(geom="ribbon", fun.data=mean_cl_normal, fill="grey")+
    # stat_summary(geom="line", fun=mean)+
   # Plot median + upper/lower quantiles:
   stat_summary(geom="ribbon", fun.min = function(x) quantile(x, 0.25), fun.max = function(x) quantile(x, 0.75), fill = "light grey") + 
    stat_summary(geom="line", fun=median)+
     coord_cartesian(ylim = c(100, 0)) +  ylab("") +
    theme_minimal() +
    theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) 

    if(x == 1){
    plot_relative_dep <- plot_relative_dep + ylab("Relative depth distribution") 
    }

    plotlist <- append(plotlist, list(plot_dep, plot_relative_dep)) 
  }

grid.arrange(grobs = plotlist, ncol = 3, as.table = FALSE)  

```


```{r num_particles, eval=FALSE}

cols_order <- c("thistle","purple","blue","green","yellow","orange","red","dark red","black")
plotlist <- list()
zlims <- c(0,15000)

for(year in years){
  timespan<-paste0(year,"-2-1-1_to_",year,"-12-31-1")

for(x in 1:2){
  run_name <- paste0(runs[x],"_",timespan)
  dat <- get(paste0(run_name,"_dat"))
  dat_sp <- SpatialPointsDataFrame(cbind(dat$lon,dat$lat), data=dat)
  
  # Counting the number of particles:
  # rasterNumParts <- rasterize(x=dat_sp[,"ID"], y=fullRaster, fun="count")
  # rasterNumParts <- as.data.frame(rasterNumParts , xy=T, na.rm=T)
  #rasterNumParts$Number <- rasterNumParts$ID
 
  # Summing the volume of particles:
  rasterNumParts <- rasterize(x=dat_sp[,"vol_particle"], y=fullRaster, fun="sum")
  rasterNumParts <- as.data.frame(rasterNumParts , xy=T, na.rm=T)
  rasterNumParts$Number <- rasterNumParts$vol_particle
  
 maxval <- max(rasterNumParts$Number)
 #zlims <- c(0, quantile(rasterNumParts$Number, 0.9999))

  fullmap <- maparea_all + 
  geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=Number), interpolate = TRUE) +
  scale_fill_gradientn(limits = zlims,
                       na.value = "red", #na.value color same as color for max value
                       colours = cols_order) +
  #scale_fill_gradientn(colours=topo.colors(500, alpha=0.4), name="Number") +
  geom_rect(aes(xmin = 17.7, xmax = 19.2, ymin =
                  min(rasterNumParts$y), ymax = 69.7), color="black",fill=NA) + 
  ggtitle(paste0(year,": ", str_to_sentence(gsub("\\P.*","",runs[x])),
                 "\nMax: ", round(maxval))) +
  theme(legend.position = c(0.85, 0.25), legend.title = element_blank(),
        legend.key.width=unit(3,"mm"),legend.background=element_blank(),
        plot.margin = unit(rep(.5, 4), "lines"),
        axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

 zoommap <- maparea_zoom + 
    geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=Number), interpolate = TRUE) +
    scale_fill_gradientn(limits = zlims,
                         na.value = "red", #na.value color same as color for max value
                         colours = cols_order) +
    xlab("Lon (°E)") + ylab("Lat (°N)") +
    theme(legend.position = "none", 
          plot.margin = unit(rep(.5, 4), "lines"),
          axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.border = element_rect(colour = "black", fill=NA))

plotlist <- append(plotlist, list(fullmap, zoommap)) 
  
rm(dat)
}
}

grid.arrange(grobs = plotlist, layout_matrix = matrix(c(1:8),nrow=2,byrow=FALSE))

```
  

 
```{r age_particles_day, eval=FALSE}

days <- firstDayMonth(unique(dat_sp$date))[seq(2,10,by=2)]

plotlist <- list()

for(x in 1:2){
  if(x == 1){zlims <- c(0,250)} else {
    zlims <- c(0,250)
  }
 dat <- get(paste0(runs[x],"_",timespan,"_dat"))
 dat_sp <- SpatialPointsDataFrame(cbind(dat$lon,dat$lat), data=dat)

  for(i in 1:length(days)){
    dat_i <- dat_sp[dat_sp$date==days[i],]
    rasterNumParts <- rasterize(x=dat_i[,"age"], y=fullRaster, fun=mean)
    rasterNumParts <- as.data.frame(rasterNumParts , xy=T, na.rm=T)
    maxval <- max(rasterNumParts$age)

    dayplot <- ggmap(maparea_zoom) + 
    geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=age)) +
    coord_cartesian() +
    scale_fill_gradientn(limits = zlims,
                         na.value = "red", #na.value color same as color for max value
                         colours = c("purple","blue", "green","yellow","orange","red"),
                         name="Number") +
    ggtitle(paste0(days[i], "\nMax: ", maxval)) +
    theme(axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.title.y=element_blank(),
          legend.position="none",
          plot.margin = unit(c(-2,0,-0.5,0), "lines"),
          plot.title=element_text(margin=margin(t=40,b=-30)),
          panel.border = element_rect(colour = "black", fill=NA, size=1))
    
    plotlist <- append(plotlist, list(dayplot)) 
  
  }
   lastplot <- ggmap(maparea_zoom) +
    geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=age)) +
    coord_cartesian() +
    scale_fill_gradientn(limits = zlims,
                         na.value = "red", #na.value color same as color for max value
                         colours = c("purple","blue", "green","yellow","orange","red"), name="Age (days)") +
    theme(legend.direction = "horizontal") 

  legend <- cowplot::get_legend(lastplot)
  plotlist <- append(plotlist, list(legend))
}


grid.arrange(grobs=plotlist, layout_matrix = matrix(c(1:12),ncol=2,byrow=FALSE),
             top=textGrob("Neutral              Sinking"))

```



# Supplemental figures
To assess if releasing 100 particles per day is sufficient to capture the general distribution patterns, we compared results for the 2018-simulation with neutrally buoyant particles to a run with 10 particles released per day. Increasing the number of particles released per day from 10 to 100 leads to a smoother cumulative distribution of river material in the fjord system and a larger total extent of material into the outer area, but the main patterns remain the same.   

```{r compare_particle_number, eval=FALSE}
# Comparing runs with 10 and 100 particles released per day (total 2420 vs. 24 200) 
year <- 2018
timespan<-paste0(year,"-2-1-1_to_",year,"-12-31-1")
runs<-c("neutralParticles_10pertimestep","neutralParticles")

for(i in 1:2){
  run_name <- paste0(runs[i],"_",timespan)
  resultfile <- paste0("../results/",run_name,".nc")
  DriftFile <- nc_open(resultfile, write=FALSE) #for nc
  #print(DriftFile)
  #id  <- ncvar_get(DriftFile, 'trajectory')  # Particle ID
  #Create vector of timesteps in days:
  timesteps  <- ncvar_get(DriftFile, 'time')  # seconds since 1970-01-01 00:00:00 
  dates <- as.Date(as.POSIXct(timesteps, origin="1970-01-01"))
  
  days_timestep<-diff(timesteps)[1]/(60*60*24) #days per timestep
  timesteps_days<-rep(NA,length(timesteps));timesteps_days[1]<-days_timestep 
  for (j in 2:length(timesteps_days)){timesteps_days[j]<-timesteps_days[j-1]+days_timestep}
  timesteps_days_rounded<-ceiling(timesteps_days)

  dates_days <- data.frame(day=timesteps_days_rounded,date=dates)
    assign(paste0("dates_days", year), dates_days)
  
  #Extract relevant variables
  status <- ncvar_get(DriftFile, 'status')    #0=active,<0=stranded/not yet released
  release_month <- ncvar_get(DriftFile, 'origin_marker');release_month[status<0]<-NA
  lon <- ncvar_get(DriftFile, 'lon');lon[status<0]<-NA
  lat <- ncvar_get(DriftFile, 'lat');lat[status<0]<-NA
  depth <- ncvar_get(DriftFile, 'z');depth[status<0]<-NA
  age_seconds <- ncvar_get(DriftFile, 'age_seconds');age_seconds[status<0]<-NA
  age_days <- floor(age_seconds/(60*60*24))
  bottom_depth <- ncvar_get(DriftFile, 'sea_floor_depth_below_sea_level');bottom_depth[status<0]<-NA
  
  nc_close(DriftFile)
  
  # Make dataframe of relevant variables
  dayvector <- rep(timesteps_days_rounded, each = dim(release_month)[2])
  datevector <- rep(dates, each = dim(release_month)[2])
  
  dat <- pivot_longer(as.data.frame(release_month), cols= 1:dim(release_month)[2], values_to = "release_month", names_to = "ID")  %>%
        mutate(day=dayvector)  %>%
        mutate(date=datevector)  %>%
        mutate(age=c(t(age_days)))  %>%
        mutate(lon=c(t(lon)))  %>%
        mutate(lat=c(t(lat)))  %>%
        mutate(depth=c(t(depth)))   %>%
        filter(!is.na(release_month))
    
  assign(paste0(run_name,"_dat"), dat)
  
  rm(resultfile, DriftFile, timesteps, days_timestep, timesteps_days, timesteps_days_rounded, release_month, status, lon, lat, depth, age_seconds, age_days, datevector)
}


# Comparing cumulative particle distribution

plotlist <- list()

for(x in 1:2){
  run_name <- paste0(runs[x],"_",timespan)
  dat <- get(paste0(run_name,"_dat"))
  dat_sp <- SpatialPointsDataFrame(cbind(dat$lon,dat$lat), data=dat)
  
  # Counting the number of particles:
  rasterNumParts <- rasterize(x=dat_sp[,"ID"], y=fullRaster, fun="count")
  rasterNumParts <- as.data.frame(rasterNumParts , xy=T, na.rm=T)
  rasterNumParts$Number <- rasterNumParts$ID
 
 maxval <- max(rasterNumParts$Number)

 if(x == 1){zlims <- c(0,300)} else {
    zlims <- c(0,3000)
  }
 
  fullmap <- ggmap(maparea_all) + 
    geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=Number), interpolate = TRUE) +
    scale_fill_gradientn(limits = zlims,
                         na.value = "red", #na.value color same as color for max value
                         colours = c("purple","blue", "green","yellow","orange","red")) +
    coord_cartesian() +
    #scale_fill_gradientn(colours=topo.colors(500, alpha=0.4), name="Number") +
    geom_rect(aes(xmin = 17.7, xmax = 19.2, ymin =
        min(rasterNumParts$y), ymax = 69.7), color="black",fill=NA) + 
    ggtitle(paste0(year,": ", runs[x],"\nMax: ", round(maxval))) +
    theme(plot.margin = unit(rep(.5, 4), "lines"),
          axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

  zoommap <- ggmap(maparea_zoom) + 
    geom_raster(data = rasterNumParts, aes(x = x, y = y, fill=Number), interpolate = TRUE) +
    coord_cartesian() +
    scale_fill_gradientn(limits = zlims,
                         na.value = "red", #na.value color same as color for max value
                         colours = c("purple","blue", "green","yellow","orange","red")) +
    xlab("Lon (°E)") + ylab("Lat (°N)") +
    theme(plot.margin = unit(rep(.5, 4), "lines"),
          axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

  # Comparing mean particle depth:
  plot_dep <- dat %>% 
   filter(age != 0) %>%
   group_by(date) %>% 
   summarise(depth = mean(depth)) %>%
    ggplot(aes(x=date,y=depth)) +
  geom_line()+
  ylim(c(-50, 0 )) +
  ylab("Mean particle depth") +
  theme_minimal() +
  theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5)) 
  

plotlist <- append(plotlist, list(fullmap, zoommap, plot_dep)) 
  
rm(dat)
}

grid.arrange(grobs = plotlist, layout_matrix = matrix(c(1:6),nrow=3,byrow=FALSE))


```


